一、开篇
1.养成写高质量代码的习惯（什么是高质量代码）
2.设计模式是如何写出读性、可扩展、可维护的代码

二、为什么要学设计模式
1.面试
2.职业素养
3.提高复杂代码的设计开发能力
4.读源码（高手也是这样玩的）

三、好坏代码的指标&怎么写出高质量的代码
1. 灵活性、
   1. 可扩展性、可维护性、可读性、可理解性、易修改、复用性、可测试性、模块化 、高内聚低耦合、高效、高性能、安全性、兼容性、易用性、整洁、清晰、简单、直接 少即是多、文档详细、分层清晰、正确性、鲁棒性、健壮性、可用性、可伸缩性、稳定性、优雅
2. 代码好坏的评价是主观的
3. 常用：
   1. 可维护性（修bug、调整老代码和添加新功能）：在不引起bug的情况下能够快速添加或者修改代码。
   2. 可读性：编码规范、命名、注释、函数长短、分层、模块、高内聚低耦合
   3. 可扩展性：不修改或者少修改原代码的基础上添加新的代码
   4. 灵活性：（有点可维护+可扩展的味道）
   5. 简洁性：KISS（保持简单的代码，我喜欢这个）
   6. 复用性：减少重复代码
   7. 可测试性：不好测的代码就是有问题的代码

四、面向对象、设计模式、设计原则、编码规范和重构
1. 面向对象的特性：有很多特性（封装、抽象、继承和多态），可以实现很多设计思路，是设计原则和设计模式的基础
2. 9 种设计原则：指导设计的经验总结，可以指导是否用某种设计模式。
3. 23 种设计模式：是针对开发过程中常见的问题总结的方案和思路，提高可扩展性
4. 编码规范：提高可读性
5. 重构：对以上4中思想的运用

五、什么是面向对象和面向对象语言
1. 面向对象是一种变成范式，以对象为组织代码单元，并将封装、抽象、继承、多态
2. 支持面向对象特性的语言

六、继承、封装和多态解决什么问题
1. 封装：访问控制权，防止任意修改，隐藏
2. 抽象：隐藏方法的具体实现，调用者只用关系有哪些方法，不关注方法实现
3. 继承：代码复用，过度继承过导致代码可读性降低，耦合度加重
4. 多态：提升代码复用

七、面向对象vs面向过程
1. oop 更易应对大规模软件开发
2. 更易复用、扩展、维护
3. 更智能

八、接口和抽象类
1. 抽象类有属性和抽象方法，出于代码复用，抽离除子类中公共的is-a
2. 接口只有抽象方法，出于解耦 契约 has-a

九、为什么要基于接口编程
1. 依赖抽象不理来实现
   1. 函数名不暴露任何实现细节
   2. 封装细节
   3. 为实现定义抽象接口
2. 抽象意识、封装意识、接口意识
3. 只有一种实现方法，未来不可能被替换的情况下就没必要基于接口编程
4. 越是不稳定的系统越要在扩展性和维护性上下功夫。

十三、面向对象分析(OOA)
1. 非业务开发要有组件化、框架化和抽象化的意识
2. 全面了解业务，全面满足需求，初步方案+反复优化
3. 使用进化算法的思想，提出一个MVP（最小可行性产品），逐步迭代改进


十四、面向对象设计(OOD)+面向读编程(OOP)
1. 面向对象设计
   1. 划分职责识别出有哪些类
      1. 罗列需求中的名词作为类的备选（或者根据需求把功能点列出来，再去进行职能分类，对于大规模的需求先分模块）
   2. 定义类的属性和方法
   3. 定义类与类之间的关系
      1. 泛化（继承）
      2. 实现（实现接口）
      3. 聚合（包含，但是不依赖）
      4. 组合（包含，依赖）
      5. 关联（聚合+组合）
      6. 依赖
   4. 组装类并提供入口

十五、单一职责
1. SRP内涵：不要设计大而全的类，要设计粒度小、功能单一的类。
2. 如何判断功能是否单一
   1. 这是个主观性比较强的问题
   2. 可以先写个粗粒度的类，根据业务背景再进行拆分。这就是所谓的重构
   3. 经验性技巧：
      1. 类中代码行数，函数或者属性过多
      2. 类中依赖其他类较多
      3. 私有方法过多
      4. 类名比较难定
      5. 类中大量方法集中操作那几个属性
3. 也并不是拆的约细越好

### 十六、对扩展开放、对修改关闭
1. 重点原则，23种设计模式主要围绕该原则展开，开闭原则讲的就是扩展性问题
2. 应该是在原有的功能上扩展，而不是在原有的基础上修改
3. 核心逻辑是没有破坏原代码的正常运行，并有破坏原有的单元测试
4. 多态、依赖注入、基于接口而非实现编程（装饰、策略、模板、责任链、状态）
5. 时刻有抽象、封装的意识, 预留扩展点
   1. 怎么预留扩展点？
      1. 面向业务的开发需要多了解业务
      2. 面向技术的开发需要了解你的软件将会被如何使用
      3. 预留扩展也不能到处预留，要有取舍
   2. 有些情况下扩展和可读性有冲突

### 十七、里氏替换
1. 内涵：子对象可以替换父对象，并且保证原来逻辑的不变性和正确性
2. 关键点：子类在设计的时候要遵守父类的行为协定，协定包涵输入、输出、异常的约定，甚至包涵特殊逻辑的约定。

### 十八、接口隔离原则
1. 客户端（调用者）不应该强迫依赖它不需要的接口。
   1. 一组接口组合
   2. 单个API或者函数
   3. OOP中的接口概念
2. 和单一职责模式很像，但是不一样的是一方面是接口设计，另一方面是思考角度不同，从调用者的角度去理解

### 十九、依赖反转
1. 控制反转(IoC, Inversion of control),框架提供一个可扩展的代码骨架，用来组装对象、管理整个执行流程，开发只需要再扩展点写自己的业务代码，就可以利用框架驱动整个业务
2. 控制指的是对程序执行流程的控制，反转是指从原本由程序员的自己控制整个程序的执行，使用框架后，整个流程由框架控制。
3. 依赖注册(DI, Dependency Inject)
   1. 不用new 方式在内部初始化类，而是将依赖的类再外部创建好之后通过构造函数、函数参数的方式传递给类使用
   2. 提升代码的可扩展性？？怎么提升的？？可以灵活的替换类？？所以依赖的就不能是类而是接口了？？
4. 依赖注册是编写可测试性代码的最有效手段
5. DI Framework 
6. 依赖反转原则(DIP)：
   1. 高层模块不要依赖低层模块
   2. 高层模块和低层模块应该通过抽象相互依赖
   3. 抽象不要依赖细节，细节要依赖抽象
7. 高层vs低层: 
   1. 调用者属于高层，被调用者属于低层
   2. 平时业务开发是高层模块依赖低层模块没问题
   3. 该原则主要指导框架层面

### 二十、KISS&YANGI
1. KISS：keep it simple stupid, 保持简洁
   1. 不要使用同事可能不懂的技术实现代码
   2. 不要重复造轮子，善于使用已有的工具类库
   3. 不要过渡优化
   4. code review 时同事对你的代码有疑问就说明你的代码不够"简单"，需要优化
2. YANGI: you ain't Gonna need it, 不要过渡设计
   1. 不要设计当前用不到的功能
   2. 不要设计当前用不到的代码
   3. 当前不需要就不做
   4. 做和留扩展还是不一样的，扩展还是得留
3. DRY：dont repeat your self, 不要重复
4. LoD：law of Demeter, 最小知识

### 二十一、DRY
1. 重复形式
   1. 实现逻辑重复
   2. 功能语义重复
   3. 代码执行重复
2. 代码复用性
   1. 代码复用：表示一种行为，尽量复用已存在的代码。
   2. 代码复用性：表示一段代码可以被复用的特性或能力，编写代码的时候尽量让代码可以复用。
   3. DRY原则：不要写重复的代码。
3. 提高复用性
   1. 减少耦合
   2. 满足单一职责
   3. 模块化
   4. 业务与非业务分离
   5. 通用代码下沉
   6. 继承、封装、多态
   7. 应用模板模式

### 二十二、LoD 迪米特法则