# 数据结构和算法

### 第二章、如何系统高效学习算法和数据结构

1. 广义数据结构：数据的存储结构
2. 广义的算法：对数据的操作
3. 数据结构是为算法服务，算法作用在特点的数据结构上
4. 复杂度分析是第一个重点
5. 20个知识点
    1. 数组、链表、队列、栈、散列表、二叉树、堆、调表、图、跳表、Trie树
    2. 递归、排序、二分查找、搜索、哈希、贪心、分治、回溯、动态规划、字符串匹配
6. 要知道来历、自身特点、适合解决的问题和实际应用场景
7. 学习技巧
    1. 边学边练，适度刷题，不动手等于白搭
    2. 不懂不丢人，勤学好问
    3. 坚持

### 第三章&第四章 复杂度分析

1. 复杂度分析是算法的精髓？？（为什么）
    1. 事后统计：qa 跑、和硬件、数据结构以及数据规模有关
    2. 大 O 复杂度表示法，粗略估计，不运行代码就能看出代码的好坏？？（牛逼啊，感觉中医和西医的区别）
    3. 大 O 表示：渐进式时间复杂度
       1. 只关注循环次数最多的一段代码
       2. 加法法则：总复杂度等于量级最大的那段代码的复杂度
       3. 乘法法则：嵌套代码的时间复杂度等于嵌套内外代码复杂度的乘积
    4. 常见复杂度表示：
       1. 多项式量级
          1. 常数
          2. 对数：O(logN)
          3. 线性
          4. 线性对数：O(N*logN)
          5. 平方、立方、...k阶`
       2. 非多项式量级
          1. 指数 2^N
          2. 阶乘 n!
       3. 非多项式量级叫做 ```NP(Non-Deterministic Polynomial, 非确定多项式问题)问题```
    5. 其他分类
       1. 最好时间复杂度（```best case time complexity```）
       2. 最坏时间复杂度(```worst case time complexity```)
       3. 平均时间复杂度(```average case time complexity```),也叫期望平均时间复杂度或者加权时间复杂度
       4. 均摊时间复杂度(```amortized case time complexity```)，把复杂的摊到前面简单的上面

### 第五章 数组
0. 数组是一组连续的内存，存储相同的数据类型的一种线性结构
   1. 连续的特性导致可以随机查询，但是不方便插入和删除
   2. 寻址公式：```a[i]_addr = base_addr + i * data_type_size``` 寻址公式导致下标从 0 开始???
1. 数组为什么从 0 开始
2. 为保持连续，导致删除和插入的复杂度提升，怎么优化？每次并不真正删除，而是标记为已删除，等全部了才真正一把删除，标记删除法（JVM），新的问题，资源浪费，另外后期插入怎么处理呢
3. 警惕数组访问越界，感觉这个问题很简单，但是比较容易忽略。大佬们每次都强调。会有各种坑啊
4. go的越界直接panic了
5. java 里的Arraylist 等同于 go 里的 slice 吗？ slice 底层是数组，也可以动态扩容。动态扩容比较耗时，所以最好定义好大小
6. N维数组的寻址公式：首先确定N维数组的底层也是一位数组，其他的是根据offset*data_type_size了
7. JVM垃圾回收标记清除垃圾回收
   1. go垃圾回收
      1. v1.5三色标记
         1. 把所有节点放入白色集合
         2. 从根节点开始遍历
         3. 遍历到的阶段从白色集合放入到灰色集合
         4. 遍历灰色集合，把灰色引用的白色集合放入到灰色，把灰色引用的灰色集合放入到黑色集合中
         5. 循环，知道灰色中没有对象
         6. 最后白色就是要清除的
      2. v1.8混合写屏障，解决遍历过程中改变引用的问题
         1. STW
         2. 除了写屏障，GC过程中生成的新对象都放入黑色

### 第六章 链表
0. 链表
   1. 不需要连续，通过指针将内存串联在一起，插入删除比较快，访问效率比较低
   2. 类型
      1. 单链表：尾结点指向空
      2. 双链表：插入和删除比单链表更高效，应用更广泛，空间换时间
      3. 循环链表：尾结点指向头结点，优点：从尾到头比较方便，约瑟夫问题
      4. 双向循环链表：
1. 缓存淘汰算法
   1. 先进先出(First in first out, FIFO)
   2. 最近最少使用(Latest Recently Used, LRU)
   3. 最少使用策略(Latest Frequently Used, LFU)
2. 判断回文字符串
3. 怎么写好链表
   1. 理解指针或者引用的含义
   2. 警惕指针的丢失和内存的泄露
   3. 利用哨兵简化难度
   4. 留意边界条件
   5. 画画图
   6. 多练
第七章 栈

第八章 队列

