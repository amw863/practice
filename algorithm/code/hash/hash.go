package hash

/**
散列源于数组，是对数组的扩展，利用数组支持随机下标访问的特性。
核心是hash函数的设计设散列冲突
开放寻址
	1. 线性探测：根据hash函数求出要查找的键值对应的散列值，然后比较数组下表中
	2. 二次探测：步长变为2的平方
	3. 双重哈希：用多个hash函数

	1. 不能物理删除
	2. 装载因子=已填充/数组长度
	3. 空闲位置越少冲突越多，散列表的性能下降

	一直纠结怎么查的，value存的值为key 的原始值和value

拉链法：桶（槽位+链表）


题目：
	1. 假设我们有10万条URL访问日志，如何按照访问次数给URL排序？
	100000 * 1KB = 100M
	放内存 hash 后计次排序【排序算法】

	2. 有两个字符串数组，每个数组大约有10万条字符串，如何快速找出两个数组中相同的字符串？
	搞个hash 分别遍历


装载因子过大，动态扩容类似数组的动态扩容

工业级hash函数思考：
	- 快速增删改查
	- 合理内存
	- 性能稳定

应用：
	LRU：hash+双链表
	Redis有序集合


hash 算法：将任意长度的二进制映射为指定长度的二进制
	- 不可逆
	- 输入敏感
	- 冲突概率小
	- 高效

种类：MD5、SHA、DES、AES
应用场景：安全加密、数据校验、唯一标识、散列函数、负载均衡、数据分片、分布式存储（一致性hash）

*/
